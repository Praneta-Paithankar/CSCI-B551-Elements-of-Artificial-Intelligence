#!/usr/bin/env python
# For 15 puzzle,initial board configuration is given in file by the user.I am using list of lists as a data structure.
# Mathematical abstraction for current 15 puzzle is as follows:
# s0={initial state given by user} e.g if user gives board configuration as
# 1 2 3 4
# 5 6 7 8
# 9 10 0 12
# 13 14 15 11 then s0={[[1,2,3,4],[5,6,7,8],[9,10,0,12],[13,14,15,11]]}
# state space S will contain all combinations of 15 puzzle which are generated by moving tiles up,down,left,right of
# initial state ,its successor and so on till goal state
# goal state={1 2 3 4
#             5 6 7 8
#             9 10 11 12
#             13 14 15 0}
# Successor function will generate successor of current state by moving one, two, or three tiles up,down,left or right
# Current state will generate six successor states.
# For this problem, I used manhattan distance and linear conflict heuristic function
# Manhattan distance calculates horizontal and/or vertical distance of tile to its goal position
# As we can move three tiles in a single move , I am dividing the manhattan distance by 3 to make it admissible
# linear conflict finds the conflict between two tiles if they are in their goal row, current position of tile
# ti is to the right of tile tj, and  goal position of ti is to left of the goal position of tj.
# if 2 tiles are in linear conflict then add 2 moves to manhattan distance.As we can move tiles only horizontally and
# vertically,so moves require to move the tiles to their goal position will take more moves than moves estimated by
# manhattan distance.So manhattan distance is admissible . If there is linear conflict on board ,it requires two moves
# to rearrange the tile as we have to move ti and then tj to reach their goal states.Therefore,linear heuritic is
# admissible
# cost =1 from current state to its successor
# Therefore, f(s) evaluation function =g(s)+h(s)
# where g(s) is cost function

# Working of program:
# I am using list of lists as data structure to store the board state, evaluation function f(s), cost g(s), heuristic
# function h(s), and moves which show the path from given state to goal state.
# so model =[fs,gs,hs,state,move]
# where state is stored as list of lists where inner list represents each row.
# e.g.[[1,2,3,4],[5,6,7,8],[9,10,0,12],[13,14,15,11]]
# After taking file name as parameter,I am reading the board configuration from file and mapping it to my model.
# Before searching for optimized path, I check permutation inversion of initial board.If parity is even then I only
# check for optimal path .If parity is even ,then I check for optimal path by using solve_16 function.Initially ,I check
# if the given state is goal state or not.If it's goal state then I terminate the search. Otherwise, I add model in
# fringe .I popped the element from fringe then I check whether element is present in closed list.If it is present then
# I am discarding the state.After that, I check the state for goal state if it is goal state then I am returning the
# state s.If it's not goal state ,I add the state in closed structure.I find its successors and add them into the fringe
# For implementing the priority queue,I used heapq.In this program ,priority is given on the basis of value of fs of
# model structure in fringe.

# discussion of any problems you faced, any assumptions, simplifications, and/or design decisions
# Initially, I implemented this program by creating class for model and used Queue.PriorityQueue of python to implement
# the priority queue structure i.e. fringe.But it was taking more time to execute the code.I referred to
# https://stackoverflow.com/questions/36991716/whats-the-difference-between-heapq-and-priorityqueue-in-python where
# it is mentioned that heapq is efficient than priority queue as it does not have locking overhead.So I changed my
# implementation to use heapq

# I removed the steps of checking whether s' is present in fringe as it is costly operation to perform because after
# removing the element from fringe.I have to perform heapify operation to transform list to heap.It takes O(n) time to
# perform heapify.(I referred the discussion on piazza to remove this part)

# In search algorithm, after generating successor,new state s' is checked whether it is present in closed or not.If it
# is not present in closed then it is added in fringe. But if we check the state in closed after popping the element
# from fringe then we eliminate the linear search for all successors in closed.We only checked for the states which are
# picked to traverse next.This way we can efficiently decrease the time complexity of algorithm. Akshay Naik(aunaik)
# suggested me this approach.


import sys,copy,heapq,math,time


# Using search algorithm3
def solve_16(initial_model):
    res = is_goal_state(initial_model[3])
    if res:
        return initial_model
    fringe = []
    heapq.heappush(fringe, initial_model)
    while len(fringe):
        s = heapq.heappop(fringe)
        if s[3] in closed:
            continue
        if is_goal_state(s[3]):
            print len(closed)
            print len(fringe)
            return s
        closed.append(s[3])
        for s1 in successors(s):
            heapq.heappush(fringe, s1)
    return False


# To check the goal state
def is_goal_state(board):
    for row in board:
        if row not in goal_board:
            return False
    return True


# To check the position of number on current board
def check_position_of_number(board, number):
    for i in range(4):
        for j in range(4):
            if board[i][j] == number:
                return i, j


# To generate the successors of current state
def successors(model):
    r, c = check_position_of_number(model[3], 0)
    new_board = []
    copy_model = copy.deepcopy(model)
    # move right
    new_board.extend(move_right(copy.deepcopy(model), r, c))
    model = copy.deepcopy(copy_model)
    # move left
    new_board.extend(move_left(model, r, c))
    # move down
    model = copy.deepcopy(copy_model)
    new_board.extend(move_down(model, r, c))
    # move up
    model = copy.deepcopy(copy_model)
    new_board.extend(move_up(model, r, c))
    return new_board


# using linear heuristic
def linear_heuristic(board):
    manhattan_distance = 0
    for row in range(4):
        for col in range(4):
            number = board[row][col]
            if number != 0:
                org_x, org_y = check_position_of_number(goal_board, number)
                manhattan_distance += abs(org_x - row) + abs(org_y - col)
    count = 0
    manhattan_distance = int(math.ceil(manhattan_distance / 3.0))
    for i in range(4):
        numbers = [num for num in board[i] if num in goal_board[i]]
        j = 1
        for num in numbers:
            if any(num > x for x in numbers[j:] if x != 0):
                count += 1
            j += 1

    for col in range(4):
        numbers = [board[row][col] for row in range(4) if (board[row][col] - 1) % 4 == col]
        j = 1
        for num in numbers:
            if any(num > x for x in numbers[j:] if x != 0):
                count += 1
            j += 1

    return manhattan_distance + (2 * count)


# To find the successor by moving tiles to left
def move_left(pmodel, r, col):
    board = pmodel[3]
    new_board = []
    block_count = 1
    while 0 <= col < 3:
        board[r][col], board[r][col + 1] = board[r][col + 1], board[r][col]
        cboard = copy.deepcopy(board)
        move = pmodel[4] + "L" + str(block_count) + str(r + 1) + " "
        gs = pmodel[1] + 1
        hs = linear_heuristic(cboard)
        fs = gs + hs
        ob = [fs, gs, hs, cboard, move]
        new_board.append(ob)
        col += 1
        block_count += 1
    return new_board


# To find the successor by moving tiles to right
def move_right(pmodel, r, col):
    board = pmodel[3]
    new_board = []
    block_count = 1
    while 1 <= col < 4:
        board[r][col], board[r][col - 1] = board[r][col - 1], board[r][col]
        cboard = copy.deepcopy(board)
        move = pmodel[4] + "R" + str(block_count) + str(r + 1) + " "
        gs = pmodel[1] + 1
        hs = linear_heuristic(cboard)
        fs = gs + hs
        ob = [fs, gs, hs, cboard, move]
        new_board.append(ob)
        col -= 1
        block_count += 1
    return new_board


# To find the successor by moving tiles to up
def move_up(pmodel, row, c):
    board = pmodel[3]
    new_board = []
    block_count = 1
    while 0 <= row < 3:
        board[row][c], board[row + 1][c] = board[row + 1][c], board[row][c]
        cboard = copy.deepcopy(board)
        move = pmodel[4] + "U" + str(block_count) + str(c + 1) + " "
        gs = pmodel[1] + 1
        hs = linear_heuristic(cboard)
        fs = gs + hs
        ob = [fs, gs, hs, cboard, move]
        new_board.append(ob)
        row += 1
        block_count += 1
    return new_board


# To find the successor by moving tiles to up
def move_down(pmodel, row, c):
    board = pmodel[3]
    new_board = []
    block_count = 1
    while 1 <= row < 4:
        board[row][c], board[row - 1][c] = board[row - 1][c], board[row][c]
        cboard = copy.deepcopy(board)
        move = pmodel[4] + "D" + str(block_count) + str(c + 1) + " "
        gs = pmodel[1] + 1
        hs = linear_heuristic(cboard)
        fs = gs + hs
        ob = [fs, gs, hs, cboard, move]
        new_board.append(ob)
        row -= 1
        block_count += 1
    return new_board


#  To find the permutation inversion
def permutation_inversion(board):
    N = 0
    for number in range(2, 16):
        r, c = check_position_of_number(board, number)
        for j in range(c, 4):
            if board[r][j] != 0 and board[r][j] < number:
                N = N + 1
        for i in range(r + 1, 4):
            for j in range(0, 4):
                if board[i][j] != 0 and board[i][j] < number:
                    N = N + 1
    r, c = check_position_of_number(board, 0)
    N = N + r + 1
    return N


goal_board = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]
closed = []


def main():
    with open(sys.argv[1], "r") as f:
        lines = f.read().split("\n")
    # [fs,gs,hs,state,move]
    initial_model = [0, 0, 0, [map(int, line.split(" ")) for line in lines], ""]
    N = permutation_inversion(initial_model[3])
    if N % 2 != 0:
        print "Not Solvable"
    else:
        old_time=time.time()
        board = solve_16(initial_model)
        new_time=time.time()-old_time
        print new_time
        print board[4]


if __name__ == main():
    main()